

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Beluki</title>
        <link rel="stylesheet" href="/static/style.css" type="text/css">
        <link rel="stylesheet" href="/static/codehilite.css" type="text/css">
    </head>

    <body>
        <div class="top-bar">
            <ul>
                <li> <a href="/">índice</a> </li>
                <li> <a href="/archive/">archivo</a> </li>
                <li> <a href="/page/about/">acerca de</a> </li>
            </ul>
        </div>
        <div class="wrapper">
            
    

    
        
    

    
        


<div class="title">
    Grandmaster
</div>

<div class="subtitle">
    octubre 29, 2015

    <div class="multilink">
        
            <a href="/archive/dir/">dir</a>

             | 
        
            <a href="/archive/grandmaster/">grandmaster</a>

            
        
    </div>
</div>

<div class="content">
    <p>Hace unos 4 meses (concretamente el 30 de Junio) terminé <a href="https://github.com/Beluki/dir">dir</a>,
un pequeño juego programado en <a href="http://www.lua.org">Lua</a>, utilizando <a href="https://love2d.org">Love2D</a> como motor.
Este post no es un postmortem acerca de dir, aunque no descarto escribir
más posts sobre los proyectos que he hecho después de <a href="/post/cosas-que-aprendi-de-GaGa/">GaGa</a>.</p>
<p>Este post va de la que es probablemente la mejor partida que se ha
jugado en dir hasta el momento. La siguiente screenshot me la envió <a href="http://verleeryescuchar.blogspot.com.es">mi
pareja</a> por email en plan "te dije que lo haría":</p>
<p><img src="/static/14.png" alt="grandmaster"></p>
<p>Si no has jugado nunca a dir, es probable que la foto no te diga gran
cosa. En dir, es realmente difícil alcanzar el ranking "grandmaster".
Hay de hacer un combo de 25x, llegar al nivel 20 y hacer más de un
millón de puntos en la misma partida.</p>
<p>Si te atreves a intentarlo, dir es gratuito y puedes descargarlo <a href="https://github.com/Beluki/dir/releases">aquí</a>.</p>
</div>


        <div class="multilink">
            <a href="/post/grandmaster/">permalink</a> |
            <a href="/post/grandmaster/#disqus_thread">comentarios</a>
        </div>
    
        


<div class="title">
    Miscelánea
</div>

<div class="subtitle">
    marzo 24, 2015

    <div class="multilink">
        
            <a href="/archive/GaGa/">GaGa</a>

             | 
        
            <a href="/archive/programacion/">programación</a>

            
        
    </div>
</div>

<div class="content">
    <p>Hace unos días me encontré con un post sobre <a href="https://github.com/Beluki/GaGa">GaGa</a> en una página
web llamada <a href="http://www.gorgeousmachine.org/2015/01/lightweight-online-radio-player-windows.html">Gorgeous Machine</a>. Estas cosas siempre hacen sonreír.
Que otros hablen bien de tus proyectos es un buen alimento para el ego.</p>
<p>En otro orden de cosas, he terminado <a href="https://github.com/Beluki/MQLite">MQLite</a>, un programa (y librería)
escrito en Python para hacer pattern-matching al estilo MQL pero
dirigido a JSON. Irónicamente, <a href="https://plus.google.com/109936836907132434202/posts/bu3z2wVqcQc">Freebase cerrará</a> su web y APIs en junio
de este año, migrando todos sus datos a Wikidata.</p>
</div>


        <div class="multilink">
            <a href="/post/miscelanea/">permalink</a> |
            <a href="/post/miscelanea/#disqus_thread">comentarios</a>
        </div>
    
        


<div class="title">
    Cosas que aprendí de... GaGa
</div>

<div class="subtitle">
    febrero 01, 2015

    <div class="multilink">
        
            <a href="/archive/postmortem/">postmortem</a>

             | 
        
            <a href="/archive/programacion/">programación</a>

            
        
    </div>
</div>

<div class="content">
    <p>GaGa es un pequeño reproductor de radios online para Windows, escrito en C#.
Es parecido a <a href="http://radiotray.sourceforge.net">RadioTray</a> para Linux, en el sentido en que se integra con
el <a href="http://en.wikipedia.org/wiki/Notification_area">área de notificación</a> del sistema.</p>
<p>Tiene esta pinta:</p>
<p><img src="/static/11.png" alt="GaGa"></p>
<h2>Arquitectura</h2>
<p>Con unas 3000 líneas de código en 18 archivos, GaGa es bastante más grande
que la mayoría de proyectos que tengo en Github (MultiHash por ejemplo
tiene unas 400 líneas). ¿Cómo organizarlo?.</p>
<p>Las pautas que seguí fueron las siguientes:</p>
<ul>
<li>
<p>Cada parte del programa ha de ser lo más independiente posible
  de las demás, de modo que se pueda sustituir si fuese necesario
  o razonar sobre ella por separado.</p>
</li>
<li>
<p>Si algo es útil para otros programas, lo escribiré como una librería
  aparte de GaGa. Cuando esté terminado, el programa final será el hilo
  conductor que una todos los componentes entre si.</p>
</li>
</ul>
<p>Y este fue el resultado:</p>
<p><img src="/static/12.png" alt="GaGa"></p>
<ul>
<li>
<p><a href="https://github.com/Beluki/GaGa/tree/master/Source/GaGa/Controls">Controls</a>: ToolStripAeroRenderer permite renderizar un menú contextual
  donde el item seleccionado tiene el mismo color que Aero en Windows,
  mientras que ToolStripLabeledTrackBar es un control que uso para los
  sliders de balance y volumen.</p>
</li>
<li>
<p><a href="https://github.com/Beluki/GaGa/tree/master/Source/GaGa/Libraries">Libraries</a>: Dos librerías, <a href="https://github.com/Beluki/mINI">mINI</a>, para leer archivos INI y <a href="https://github.com/Beluki/LowKey">LowKey</a>
  para poder tomar el control de teclas multimedia a bajo nivel.</p>
</li>
<li>
<p><a href="https://github.com/Beluki/GaGa/tree/master/Source/GaGa/NotifyIconPlayer">NotifyIconPlayer</a>: Implementa el reproductor, basado en el motor de
  Windows Media Player. Toma control del icono en el tray para mostrar
  su estado actual (por ejemplo, "buffering") o posibles errores.</p>
</li>
<li>
<p><a href="https://github.com/Beluki/GaGa/tree/master/Source/GaGa/StreamsFile">StreamsFile</a>: Lee archivos INI y añade sus stream a un menú contextual
  recargándolo automáticamente cuando sea necesario.</p>
</li>
</ul>
<p>Finalmente, GaGa (GaGa.cs y GaGaSettings.cs) solo implementa el menú y la
lógica de los eventos que se derivan de él, como reproducir una radio al hacer
click en el stream correspondiente. Sirve para unir todo lo anterior.</p>
<p>Curiosidades del diseño:</p>
<ul>
<li>
<p>Todas las excepciones se controlan a nivel de GaGa.cs en lugar de en cada
  componente. Es el punto más cercano al usuario, donde es más fácil determinar
  qué hacer con cada error (normalmente, mostrar un mensaje).</p>
</li>
<li>
<p>Los elementos gráficos son: el menú, icono, tooltip al dejar el ratón sobre
  el icono y los posibles mensajes sobre el icono. Que la clase Player.cs tome
  el control de todos menos el menú simplifica enormemente el código de GaGa.cs</p>
</li>
<li>
<p>Los métodos que exponen todas las clases hacia GaGa.cs son los mínimos
  posibles. Por ejemplo, StreamsFile solo expone LoadTo() (cargar el INI en un
  menú) y MustReload() (determina si el INI ha cambiado y necesita recargarse).</p>
</li>
</ul>
<p>Diría que la lección más importante en este punto es: organiza el programa de
modo que necesites tener en tu cabeza el mínimo contenido posible para poder
analizar su funcionamiento.</p>
<h2>mINI y LowKey</h2>
<p><a href="https://github.com/Beluki/mINI">mINI</a> es una pequeña librería que sirve para leer archivos INI. Es curioso
que aunque el formato <a href="http://en.wikipedia.org/wiki/INI_file">INI</a> sea predominante en Windows, .NET no tenga nada
en la librería standard para usarlo.</p>
<p>Lo más interesante de mINI es que no guarda dato alguno del archivo que está
leyendo. Es una clase abstracta con métodos como OnSection(String section)
que las subclases implementan para decidir qué hacer con los datos. Este
diseño es el que permite recargar el menú de GaGa con la mínima latencia
posible, dado que no hay estructuras de datos intermedias.</p>
<p>Escribí mINI en un fin de semana y la verdad es que estoy contento con el
resultado. Es simple, práctico, funciona.</p>
<p><a href="https://github.com/Beluki/LowKey">LowKey</a> es mucho más complicado. Es una librería que responde a pulsaciones
de teclas desde cualquier aplicación utilizando <a href="http://en.wikipedia.org/wiki/Hooking">hooks</a> a bajo nivel.
Aunque su código es relativamente corto, hay partes en las que es fácil
cometer un error.</p>
<p>Dos ejemplos:</p>
<ul>
<li>
<p>Para poder responder a cada pulsación sin bloquear el thread actual,
  uso <a href="https://msdn.microsoft.com/en-us/library/cc190824%28v=vs.110%29.aspx">BeginInvoke</a> en el <a href="https://msdn.microsoft.com/en-us/library/System.Windows.Threading.Dispatcher%28v=vs.110%29.aspx">Dispatcher</a> del thread que creó la instancia
  de LowKey. Esto permite reenviar la pulsación a otras aplicaciones
  inmediatamente, sin esperar a que el evento de LowKey se controle,
  pero también utilizar LowKey en GUIs (si el thread actual es el de la GUI).</p>
</li>
<li>
<p>El callback que LowKey usa internamente hacia la API de Windows es estático.
  Esto evita que el <a href="http://stackoverflow.com/questions/9102814/how-to-hook-an-application">colector de basura lo colecte</a>.</p>
</li>
</ul>
<h2>.NET Framework</h2>
<p>C# es, en general, un lenguaje excelente. Un buen ejemplo es el modo en el
que GaGa hace la animación en su icono de "buffering", que tiene esta
pinta:</p>
<p><img src="/static/13.gif" alt="Buffering"></p>
<p>Implementado así (fragmento):</p>
<div class="codehilite"><pre><span class="c1">// iconos que vamos a usar:</span>
<span class="k">private</span> <span class="k">readonly</span> <span class="n">Icon</span><span class="p">[]</span> <span class="n">bufferingIcons</span><span class="p">;</span>

<span class="c1">// temporizador para cambiar de icono:</span>
<span class="k">private</span> <span class="k">readonly</span> <span class="n">DispatcherTimer</span> <span class="n">bufferingIconTimer</span><span class="p">;</span>

<span class="c1">// índice del icono actual en el array bufferingIcons:</span>
<span class="k">private</span> <span class="n">Int32</span> <span class="n">currentBufferingIcon</span><span class="p">;</span>

<span class="k">public</span> <span class="nf">Player</span><span class="p">(</span><span class="n">NotifyIcon</span> <span class="n">icon</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="c1">// 300 milisegundos entre icono e icono:</span>
    <span class="n">bufferingIconTimer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">DispatcherTimer</span><span class="p">(</span><span class="n">DispatcherPriority</span><span class="p">.</span><span class="n">Background</span><span class="p">);</span>
    <span class="n">bufferingIconTimer</span><span class="p">.</span><span class="n">Interval</span> <span class="p">=</span> <span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromMilliseconds</span><span class="p">(</span><span class="m">300</span><span class="p">);</span>
    <span class="n">bufferingIconTimer</span><span class="p">.</span><span class="n">Tick</span> <span class="p">+=</span> <span class="n">OnBufferingIconTimerTick</span><span class="p">;</span>
    <span class="n">currentBufferingIcon</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">OnBufferingIconTimerTick</span><span class="p">(</span><span class="n">Object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// cambiar icono:</span>
    <span class="n">notifyIcon</span><span class="p">.</span><span class="n">Icon</span> <span class="p">=</span> <span class="n">bufferingIcons</span><span class="p">[</span><span class="n">currentBufferingIcon</span><span class="p">];</span>

    <span class="c1">// ir al siguiente icono o volver el primero si es necesario:</span>
    <span class="n">currentBufferingIcon</span><span class="p">++;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">currentBufferingIcon</span> <span class="p">==</span> <span class="n">bufferingIcons</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">currentBufferingIcon</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Un simple <a href="https://msdn.microsoft.com/en-us/library/system.windows.threading.dispatchertimer%28v=vs.110%29.aspx">DispatcherTimer</a> que se ejecuta en el thread actual con prioridad
lo más baja posible (dado que no es algo que requiera precisión). Ojalá todos
los lenguajes tuviesen algo similar.</p>
<p>Por desgracia, no puedo decir lo mismo de <a href="http://en.wikipedia.org/wiki/Windows_Forms">Windows Forms</a> o de otras partes
de la librería standard. Aunque sobre el papel es genial, en la práctica hay
comportamientos extraños y bugs que hacen su uso incómodo y que llevan
fácilmente a errores por parte del programador.</p>
<p>Algunos ejemplos (no exhaustivo):</p>
<ul>
<li>
<p>Cuando en un menú (de ContextMenuStrip) hay un item antes de un submenú,
  a veces el submenú no se abre automáticamente al pasar el ratón por encima.
  Esto no es un problema en casi ninguna aplicación porque normalmente los
  submenús están ordenados primero. GaGa respeta el orden que el usuario
  establece en el archivo INI.</p>
</li>
<li>
<p>El reproductor (MediaPlayer, de System.Windows.Media) continúa bajando
  datos de streams online tras llamar al método Stop(), es necesario ejecutar
  Close() también. Ejecutar Close() resetea el volumen y balance a su valor
  por defecto.</p>
</li>
<li>
<p>Pulsar la tecla alt cierra automáticamente un menú contextual.</p>
</li>
<li>
<p>ContextMenu (no ContextMenuStrip) guarda su anchura en algún tipo de caché.
  Es necesario borrar y recrear el menú entero si se desea que su contenido
  sea dinámico o la anchura del menú es incorrecta.</p>
</li>
<li>
<p>Ejecutar Clear() para <a href="http://stackoverflow.com/questions/1969024/does-calling-clear-disposes-the-items-also">limpiar un ContextMenuStrip</a> es insuficiente.
  Hace falta llamar a Dispose() para borrar todos los ToolStripMenuItem
  o controles que este contenga.</p>
</li>
<li>
<p><a href="https://msdn.microsoft.com/en-us/library/system.io.file.getlastwritetimeutc%28v=vs.110%29.aspx">File.GetLastWriteTimeUtc</a> devuelve 12:00, 1 de Enero de 1601 cuando un
  archivo no existe. A pesar de ello, puede lanzar 5 tipos de excepciones
  distintas cuando el archivo existe pero no hay permisos para acceder
  a él o casos similares.</p>
</li>
<li>
<p>No hay modo standard de abrir un ContextMenuStrip en el punto exacto donde
  está el ratón al hacer click, tal como se muestra automáticamente al hacer
  click derecho en el icono. Es necesario acceder a un método privado:
  ShowInTaskBar (usando Reflection) para poder hacerlo.</p>
</li>
</ul>
<h2>Conclusiones</h2>
<p>Estoy muy satisfecho con GaGa.</p>
<p>Casi todos mis programas son utilidades de consola diseñadas para usuarios
avanzados (o para programadores), pero GaGa es útil para cualquier persona con
un ordenador. Ha sido un reto interesante.</p>
<p>Además, una vez conseguí escuchar Radio GaGa de Queen en el propio GaGa
(en la radio KissFM), lo que no tiene precio.</p>
<p>Repositorios en Github: <a href="https://github.com/Beluki/GaGa">GaGa</a> - <a href="https://github.com/Beluki/LowKey">LowKey</a> - <a href="https://github.com/Beluki/mINI">mINI</a></p>
</div>


        <div class="multilink">
            <a href="/post/cosas-que-aprendi-de-GaGa/">permalink</a> |
            <a href="/post/cosas-que-aprendi-de-GaGa/#disqus_thread">comentarios</a>
        </div>
    
        


<div class="title">
    Cosas que aprendí de... MultiHash
</div>

<div class="subtitle">
    enero 21, 2015

    <div class="multilink">
        
            <a href="/archive/postmortem/">postmortem</a>

             | 
        
            <a href="/archive/programacion/">programación</a>

            
        
    </div>
</div>

<div class="content">
    <p>MultiHash es un pequeño programa escrito en Python que calcula algoritmos
como md5, sha1, sha256 etc... al estilo de <a href="http://www.gnu.org/software/coreutils/manual/html_node/md5sum-invocation.html#md5sum-invocation">md5sum</a> o <a href="http://www.gnu.org/software/coreutils/manual/html_node/sha1sum-invocation.html#sha1sum-invocation">sha1sum</a>
de <a href="http://www.gnu.org/software/coreutils">coreutils</a>.</p>
<p>Su principal baza es que puede calcular múltiples algoritmos (de ahí el nombre)
leyendo cada archivo una sola vez. Además, puede dividir el trabajo en hilos,
donde cada hilo lee y calcula los algoritmos para un archivo. Es posible
ejecutar tantos hilos como se desee de manera concurrente, aunque lo usual
es utilizar el mismo número que procesadores hay en el sistema.</p>
<p>Este post será corto porque la parte más interesante, de la que más aprendí,
es sin duda el threadpool y ya hice en su día <a href="http://beluki.github.io/post/respuesta-inmediata-con-multiples-hilos/">un post</a> sobre ello,
detallando todo el proceso. Aún así, alguna que otra cosa sí puedo contar...</p>
<h2>Python y múltiples hilos</h2>
<p>A cualquiera que conozca Python un poco, le extrañará que lo haya escogido para
crear MultiHash. Un estigma comúnmente asociado a Python es que su soporte para
threads es horrible debido al <a href="https://en.wikipedia.org/wiki/Global_Interpreter_Lock">GIL</a>.</p>
<p>Yo no estoy de acuerdo.</p>
<p>El GIL o "Global Interpreter Lock" es un mecanismo que solo permite ejecutar
código Python (bytecode) en un thread a la vez. Es imposible aprovechar
múltiples procesadores con código Python puro.</p>
<p>La palabra importante es "puro". Las extensiones escritas en C (o en <a href="http://cython.org">Cython</a>)
pueden saltarse esta limitación, permitiendo usar tantos threads como sea
necesario. Si uno mira el código de <a href="https://hg.python.org/cpython/file/tip/Modules/hashlib.h">hashlib.h</a>, la cabecera principal de
la librería que MultiHash usa para calcular los algoritmos, encuentra:</p>
<div class="codehilite"><pre><span class="cm">/*</span>
<span class="cm"> * Helper code to synchronize access to the hash object when the GIL is</span>
<span class="cm"> * released around a CPU consuming hashlib operation. All code paths that</span>
<span class="cm"> * access a mutable part of obj must be enclosed in a ENTER_HASHLIB /</span>
<span class="cm"> * LEAVE_HASHLIB block or explicitly acquire and release the lock inside</span>
<span class="cm"> * a PY_BEGIN / END_ALLOW_THREADS block if they wish to release the GIL for</span>
<span class="cm"> * an operation.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef WITH_THREAD</span>
<span class="cp">#include &quot;pythread.h&quot;</span>
    <span class="cp">#define ENTER_HASHLIB(obj) \</span>
<span class="cp">        if ((obj)-&gt;lock) { \</span>
<span class="cp">            if (!PyThread_acquire_lock((obj)-&gt;lock, 0)) { \</span>
<span class="cp">                Py_BEGIN_ALLOW_THREADS \</span>
<span class="cp">                PyThread_acquire_lock((obj)-&gt;lock, 1); \</span>
<span class="cp">                Py_END_ALLOW_THREADS \</span>
<span class="cp">            } \</span>
<span class="cp">        }</span>
    <span class="cp">#define LEAVE_HASHLIB(obj) \</span>
<span class="cp">        if ((obj)-&gt;lock) { \</span>
<span class="cp">            PyThread_release_lock((obj)-&gt;lock); \</span>
<span class="cp">        }</span>
<span class="cp">#else</span>
    <span class="cp">#define ENTER_HASHLIB(obj)</span>
    <span class="cp">#define LEAVE_HASHLIB(obj)</span>
<span class="cp">#endif</span>
</pre></div>


<p>Todos los algoritmos usan ENTER_HASHLIB() para saltarse el GIL antes de
empezar sus cálculos, así que es perfectamente viable usar threads. El
rendimiento de MultiHash escala sin problemas a tantos procesadores como
haya en el sistema.</p>
<p>Además, según mi experiencia, hay dos tipos de programas:</p>
<ul>
<li>
<p>Aquellos en los que el rendimiento "no importa", porque están limitados
  por otros factores, como la velocidad de transmisión de datos en un socket.
  Un ejemplo de esto es un cliente de IRC o el comando "ping". En estos casos
  el rendimiento de Python es más que suficiente.</p>
</li>
<li>
<p>Aquellos en los que hasta el último segundo importa, como un raytracer o
  procesamiento de imágenes. En estos casos, con o sin GIL, Python nunca te
  daría una velocidad aceptable, así que no queda otra que escribir la parte
  importante en un lenguaje como C.</p>
</li>
</ul>
<p>Aún así, sí existen modos de saltarse el GIL con código Python puro, como
usar <a href="https://docs.python.org/3/library/multiprocessing.html">multiprocessing</a>, que usa subprocesos en lugar de threads.</p>
<h2>Texto o binario</h2>
<p>Cuando se abre un archivo, se puede abrir en modo texto o en modo binario.
Increíblemente, md5sum, sha1sum, etc... abren sus archivos en modo texto
por defecto.</p>
<p>Linux (y en general Unix), no distingue entre archivos de texto y binario,
pero Windows sí y el resultado de un checksum es diferente. Esto ha llevado
a <a href="http://lists.gnu.org/archive/html/bug-coreutils/2009-03/msg00376.html">problemas de compatibilidad</a> en sistemas como <a href="http://cygwin.com">Cygwin</a> (o en ports
de md5sum a Windows).</p>
<p>MultiHash siempre lee los archivos en modo binario, que es lo único que tiene
sentido para calcular hashes. Por compatibilidad con las herramientas de
coreutils, su salida añade un asterisco '*' antes del nombre de cada fichero.</p>
<h2>Conclusiones</h2>
<p>En el último postmortem escribía que HexPaste fue creado por necesidad, porque
no había una herramienta que me permitiese pegar poemas línea a línea en IRC.</p>
<p>MultiHash sin embargo, nació de una idea muy simple: "¿Y si calculamos todos los
algoritmos a la vez?". La intención es aplicarlo a cosas como las <a href="http://cdimage.debian.org/debian-cd/7.8.0/i386/iso-cd/">ISOs de Debian</a>
u otras distribuciones, que siempre incluyen todos los checksum.</p>
<p>Ha sido también mi primera experiencia creando un programa multihilo y la verdad
es que no me puedo quejar, ha sido divertido. Es un poco trampa, porque dado que
todos los hilos son completamente independientes entre sí, no me he tenido que
pegar con mutex y las cosas realmente complicadas.</p>
<p>Repositorios en Github: <a href="https://github.com/Beluki/MultiHash">MultiHash</a></p>
</div>


        <div class="multilink">
            <a href="/post/cosas-que-aprendi-de-MultiHash/">permalink</a> |
            <a href="/post/cosas-que-aprendi-de-MultiHash/#disqus_thread">comentarios</a>
        </div>
    
        


<div class="title">
    Cosas que aprendí de... HexPaste
</div>

<div class="subtitle">
    enero 08, 2015

    <div class="multilink">
        
            <a href="/archive/postmortem/">postmortem</a>

             | 
        
            <a href="/archive/programacion/">programación</a>

            
        
    </div>
</div>

<div class="content">
    <p>Siempre me ha gustado la literatura, especialmente la poesía. Por eso, a veces
comparto aquí las cosillas que voy escribiendo. También por eso, el primer
canal de IRC al que entré hace años era de poesía: #poesia en IRC-Hispano.</p>
<p>Aunque ahora es muy diferente, por aquel entonces el canal era un pequeño y
acogedor grupo de amigos compartiendo poemas. Lorca, Miguel Hernández, Rafael
De León... un poco de todo. De todo esto hace unos 12 años.</p>
<p>Lo primero que aprendí es que copiar y pegar un poema a mano no es práctico.
La mayoría de usuarios (yo incluído) usábamos un comando de <a href="http://www.mirc.com">mIRC</a> que se
llama /play para recitar.</p>
<p>Tiene esta pinta:</p>
<p><img src="/static/10.png" alt="play"></p>
<p>Lo más útil es que permite especificar un retardo entre líneas de modo que el
poema vaya apareciendo poco a poco y sea cómodo de leer. Así fue como recité
durante años, hasta que llegó un momento en el que quise probar linux y otros
sistemas operativos.</p>
<h2>XChat</h2>
<p>Lo más parecido a mIRC para linux es <a href="http://xchat.org">XChat</a>. XChat está bien pero no tiene
nada que se parezca al comando /play, así que sin un plugin para poder recitar
volví a tener que recitar los poemas a mano.</p>
<p>Aunque por aquel entonces tampoco tenía mucha idea de programación, decidí intentar
hacer mi propio plugin para XChat que me permitiese recitar poemas en el canal.
Este fue el origen de HexPaste, que es quizá el programa más antiguo (al menos
sus raíces) de todos los que tengo actualmente en Github.</p>
<p>En su momento, escribí ese plugin en <a href="https://www.perl.org">Perl</a> y era extremadamente limitado.
Por no poder no podías ni cambiar de pestaña durante un recitado porque siempre
pegaba el texto a la pestaña actualmente activa.</p>
<h2>HexChat y HexPaste</h2>
<p>Tras unos cuantos años un poco alejado del canal y sus quehaceres, al final volví.
Supongo que el gusanillo de la poesía está siempre ahí. XChat es ahora un proyecto
fantasma (su última actualización es de hace 5 años) y lo que se lleva es <a href="http://hexchat.github.io">HexChat</a>.</p>
<p>Con más conocimientos, decidí reescribir aquel plugin que había hecho en Perl pero
en Python, mucho más robusto y práctico que antaño. Esta vez, añadiría cosas como
poder recitar en múltiples canales a la vez o que sustituyese líneas en blanco en
un archivo por espacios.</p>
<p><a href="https://github.com/Beluki/HexPaste">HexPaste</a> es en realidad un programa muy simple. Son unas 350 líneas de código
escritas en Python 3. No hubo grandes problemas durante su desarrollo en cuestión
de arquitectura porque tenía bastante claro lo que buscaba.</p>
<p>El mayor problema fue la <a href="http://hexchat.readthedocs.org/en/latest/script_python.html">API para Python de HexChat</a>. Esta API es poco más que
la API de C pero expuesta a Python, sin ningún tipo de ayuda o intención por hacerla
más idiomática a lo que un programador de Python esperaría:</p>
<ul>
<li>
<p>Muchos campos son bitfields.</p>
</li>
<li>
<p>Un "contexto" (canal, query) del tipo que <a href="http://hexchat.readthedocs.org/en/latest/script_python.html#hexchat.get_context">hexchat.get_context()</a> devuelve
  no es "hashable" y no se puede usar como clave en un diccionario de Python.</p>
</li>
<li>
<p>Muchas veces HexChat se come las excepciones, sin mostrar mensaje de error alguno.</p>
</li>
<li>
<p>Como se usan timers en lugar de threads es extremadamente fácil hacer que HexChat
  pete completamente debido a un bug y tengas que reabrirlo.</p>
</li>
</ul>
<p>Tengo la teoría de que es esta API la culpable de que la mayoría de plugins para
HexChat (y antes XChat) sean juguetes comparados con los que existen para mIRC
y otros clientes de IRC.</p>
<p>Por lo demás, tacos mediante, HexPaste fue más o menos fácil de crear. Y fácil
de portar de Python 2 a Python 3. Es uno de los proyectos que más he usado de
los que he hecho.</p>
<h2>Conclusiones</h2>
<p>Creo que la lección más importante que he aprendido de HexPaste es que la necesidad
es una buena compañera de proyectos.</p>
<p>Muchos programas parten de ideas interesantes a explorar, donde hay que hacer una
mayor labor de diseño que de programación. Este parte de necesitar algo que no existe
para aliviar la incomodidad de copiar/pegar a mano. Hay pocas satisfacciones mejores
que usar diaramente algo que has creado tú.</p>
<p>Repositorios en Github: <a href="https://github.com/Beluki/HexPaste">HexPaste</a></p>
</div>


        <div class="multilink">
            <a href="/post/cosas-que-aprendi-de-HexPaste/">permalink</a> |
            <a href="/post/cosas-que-aprendi-de-HexPaste/#disqus_thread">comentarios</a>
        </div>
    

    
        <div class="prevnext">
            <ul>
                

                
                    <li> <a href="/2/">anterior &raquo;</a> </li>
                
            </ul>
        </div>
    

        </div>
    </body>
</html>
